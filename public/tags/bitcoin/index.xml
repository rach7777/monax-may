<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
&lt;?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bitcoin on Monax Industries</title>
    <link>http://localhost/tags/bitcoin/</link>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Feb 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost/tags/bitcoin/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>On Applications and Consensus</title>
      <link>http://localhost/2016/02/22/apps-and-consensus/</link>
      <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2016/02/22/apps-and-consensus/</guid>
      <description>&lt;p&gt;Bitcoin appears to have introduced something new to the world. The question is, what? The term &amp;ldquo;blockchain&amp;rdquo; will be entirely useless to our discussion, so let&amp;rsquo;s dispense with it, for now. Instead, let&amp;rsquo;s treat Bitcoin like any other internet service. It has an application state; in this case, a currency. It has a mechanism to maintain this application state; in this case, a digital consensus engine. What is unique about bitcoin is the relationship between its application state and its consensus engine.
Almost every major internet service uses a digital consensus engine to support an application state. By application state, we mean any form of application and the set of state transitions it undergoes, be it file sharing, social media, online banking, or financial trading. By digital consensus engine, we mean a network protocol that permits a set of computers to synchronize updates to their state. A digital consensus engine allows an application to be replicated across multiple machines without getting confused.&lt;/p&gt;

&lt;p&gt;Most digital consensus engines are based on a form of the Paxos algorithm. Some might be built on other fault-tolerant algorithms designed over the last few decades, with varying tolerance for various forms of fault. In all these cases, the agents (nodes/machines/peers/participants/whatever) of the consensus are involved in rounds of communication which enable them to determine what information is available to other agents, and thereby come to unanimous agreement on what the next entry in the transaction log should be.&lt;/p&gt;

&lt;p&gt;Unlike other internet services, Bitcoin sought an alternative approach to the consensus problem. In particular, Bitcoin introduced an economic solution whereby consensus is updated not according to the particular information available to other agents, but according to the &lt;em&gt;cost&lt;/em&gt; of producing whatever information is found to be available to them. This is the notorious Proof-of-Work (PoW) algorithm.&lt;/p&gt;

&lt;p&gt;What really makes Bitcoin possible, however, is a unique coupling between the application state and the consensus engine: Bitcoin bootstraps its consensus using the very application state the consensus is intended to support. In other words, it uses the application state to directly incentivize the cost of consensus, by providing new currency units to agents able to prove that they incurred some cost on behalf of the network, and are thereby eligible to be leader of a consensus round (approve a block).&lt;/p&gt;

&lt;p&gt;This is in sharp contrast to every other known internet service, where incentivization takes place outside the application state; typically, the application state is something useful to users, producing a revenue stream for a company which thereby funds the maintenance of hardware/software/network-links that sustains the consensus supporting the application. &lt;strong&gt;That is, there&amp;rsquo;s a third entity, a company, mediating the relationship between consensus and application.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In Bitcoin, tight integration between application state (the currency) and consensus (the economic solution to which is bootstrapped by the currency), without a third party mediator (a company), results in a system where &lt;em&gt;every state transition is recorded in the consensus engine.&lt;/em&gt; Furthermore, each change is accompanied by digital signatures (elliptic curve) and data integrity checks (merkle trees). The recording of every change and its cryptographic verifiability are necessary so that, in the absence of a company, any user can confirm that the consensus is where it should be by re-running the entire history.&lt;/p&gt;

&lt;p&gt;This is an enormous overhead not incurred by a typical internet service; Amazon&amp;rsquo;s consensus engine is far too expensive and slow to record, consistently, every single change made to your shopping cart. Besides, we trust Amazon, because, at least in theory, if they mess up they lose our business.
So Amazon provides a shopping cart that is always available for new writes, even conflicting ones taking place across a network partition. Recording each such write in the consensus engine, in a manner which demanded consistency (as typical consensus engines do) would make the shopping cart experience unbearably slow. The consensus engine is thus interested only in &amp;ldquo;more important&amp;rdquo; state transitions; perhaps initializing shopping carts for new accounts, following through with payments, scaling up the number of hosts offering the shopping cart service, etc. Things far removed from the actual user experience.&lt;/p&gt;

&lt;p&gt;In principle, then, Bitcoin and the Amazon shopping cart are the same: internet services with an application state supported by a consensus engine.
The key differences are two-fold:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1) bitcoin bootstraps the consensus by incentivizing it through the application itself
2) every single state transition in bitcoin is recorded in the consensus engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, everyone is most excited about a consequence of the first difference, namely, that the agents of the consensus engine may be a decentralized group of peers, rather than the pawns of Jeff Bezos. But the second difference suggests a means by which socioeconomic systems can standardize
the production and verification of assurances over the existence and integrity of data and the execution of programs which use and update that data.&lt;/p&gt;

&lt;p&gt;Ok, so if Bitcoin is an application (currency), where every change is recorded and cryptographically verifiable (through merkle trees and digital signatures), and where the consensus is incentivized by the application itself, in a manner which is tolerant of malicious behaviour, what&amp;rsquo;s a blockchain?&lt;/p&gt;

&lt;p&gt;Algorithms tolerant to malicious or arbitrary behaviour by their agents are known as Byzantine Fault Tolerant (BFT). BFT is notoriously expensive and most approaches are impractical.  But beginning in the late 90s, a class of so-called Practical BFT (PBFT) algorithms were discovered, which, combined with efficient cryptography and faster machines, yield production quality optimally fault tolerant byzantine systems.&lt;/p&gt;

&lt;p&gt;Hence, Bitcoin can be summarized as an application where: 1) every change is recorded with digital signatures in a merkle tree, 2) networking is done in a peer-to-peer manner using a BFT consensus protocol, and 3) the guarantee of consensus derives from economic incentivization bootstrapped by the application.&lt;/p&gt;

&lt;p&gt;Let us define a blockchain then, as BFT + merkle trees + digital signatures + p2p, and say that Bitcoin is a blockchain that uses an economic solution to the BFT consensus.&lt;/p&gt;

&lt;p&gt;Now, Bitcoin became popular because of its censorship resistance, its immutability, its transparency, and its privacy. A blockchain alone can provide transparency and privacy, but without an economic element to the consensus, it is arguably impossible to provide censorship resistance or immutability. That being said, virtually every use-case of blockchain proposed today has, at least,  a meta-economic element which may contribute to these properties, if only the consumers and clients demand them. Of course, that is arguably the situation with all modern business and the very notion of competitive markets; the difference is the lack of transparency. The use of merkle trees, digital signatures, and peer-to-peer networking allows diverse sets of agents to record pieces of a transaction log&amp;rsquo;s history, and bring them to light as cryptographic proof in the event of wrong doing.&lt;/p&gt;

&lt;p&gt;It should be immediately apparent that such an arrangement of technologies, tweaked along their degrees of freedom (the consensus protocol, the economics, the application state and its cryptography, the relationship between economics and application state), will yield a versatile set of important networked systems, in particular for the coordination of consortia of organizations, and especially for governance. However, it is critical that we are able to adequately experiment with the components, and that we have the right toolsets and software architectures to do so.&lt;/p&gt;

&lt;p&gt;For this reason, we have introduced a new blockchain architecture, which makes explicit, at the process level, the distinction between the consensus engine and the application state. That is, the application and the consensus engine run in separate processes on the operating system, and communicate with each other via a simple socket protocol. This architecture is similar in spirit to that which has been used to serve websites on the internet for decades, namely, by having an http server and the actual web-application in separate processes: requests are received by the web server, filtered, and forwarded to the application. Our blockchain design is no different, except that the server component is replicated across many nodes and achieves consensus on a request before it is forwarded to the application state. Hence, we can easily write blockchain applications in any programming language, while the networking, consensus, and blockchain storage is all handled under the hood.&lt;/p&gt;

&lt;p&gt;Ethereum, of course, pioneered the notion of arbitrary applicate state on a blockchain. But they did so within their own sandboxed and somewhat cumbersome virtual environment. Our new architecture breaks the shackles of the ethereum virtual machine, allowing developers to use the programming language and tooling ecosystem that works for them.&lt;/p&gt;

&lt;p&gt;To read more about the socket protocol underlying the new architecture, see &lt;a href=&#34;http://tendermint.com/posts/tendermint-socket-protocol/&#34; target=&#34;_blank&#34;&gt;the tendermint blog&lt;/a&gt;. And stay tuned for updates on new applications!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Immutability for Bitcoin and Permissioned Ledgers</title>
      <link>http://localhost/2015/08/19/immutability-bitcoin-and-permissioned-ledgers/</link>
      <pubDate>Wed, 19 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2015/08/19/immutability-bitcoin-and-permissioned-ledgers/</guid>
      <description>&lt;p&gt;Last week, I gave my first talk about Eris at the &lt;a href=&#34;http://www.meetup.com/Bitcoin-Startups-Berlin/&#34; target=&#34;_blank&#34;&gt;Bitcoin Startups Berlin&lt;/a&gt; meetup. I know most people there so I knew this would be a friendly audience. At the same time, what we do at Eris doesn’t square with the ideologies of some in the Bitcoin space, so I did anticipate some pushback.&lt;/p&gt;

&lt;p&gt;In the end, it was Jörg Platzer, owner of the world’s oldest Bitcoin-accepting establishment, Room 77, who took the most offense. He was obviously displeased at the notion of permissioned ledgers in general, but the one aspect where he debated me the most was the issue of immutability.&lt;/p&gt;

&lt;p&gt;I claimed that public blockchains are fairly immutable. True, there is the risk of a 51% attack or chain reorganization, but that has happened very rarely so far (at least on the Bitcoin network). But what about permissioned chains? My argument was that immutability varies depending on design, whereas Jörg Platzer insisted they are mutable.&lt;/p&gt;

&lt;h1&gt;What is immutability anyway?&lt;/h1&gt;
But let me take a step back from the technical aspects and look at immutability more generally. ‘Immutable’ means [unable to be changed](http://www.oxforddictionaries.com/definition/english/immutable). In the case of a blockchain, immutability presumably means that it is not possible to go back and rewrite the history. Strictly speaking it is possible to rewrite Bitcoin’s history making Bitcoin mutable. The only caveat is that the attacker has to create a longer chain and that is generally prohibitively expensive.
 
Immutability is an essential trait for Bitcoin. Satoshi described Bitcoin in his [famous whitepaper](https://bitcoin.org/bitcoin.pdf) as a ‘version of electronic cash’. The cash analogy makes it easy to see why things break down when the ledger becomes mutable. If I pay for a coffee with bitcoin, but later the history gets changed and my payment gets reversed, transactions can’t be relied on anymore. If this happened regularly, Bitcoin would becomes useless.
 
&lt;h1&gt;What about permissioned chains?&lt;/h1&gt;

&lt;p&gt;Does immutability have similar importance in the case of permissioned chains? Our thesis at Eris is that blockchains and smart contracts will have wide-reaching implications. &lt;a href=&#34;https://db.erisindustries.com/distributed%20business/2014/12/17/blockchain-your-business/&#34; target=&#34;_blank&#34;&gt;Use cases and application contexts will vary widely&lt;/a&gt; as will the designs and capabilities of chains. Presumably, some of these could include assets that are cash-like, where one would want a similar degree of immutability as in Bitcoin. But what about the rest?&lt;/p&gt;

&lt;p&gt;One way we think about the utility of blockchains, particularly smart contract-enabled ones, is that they provide process assurance. They allow different parties to run a process in a predictable and auditable way with permissions and capabilities being assigned upfront in a transparent way. The benefits of that could include making existing processes more efficient, allowing business relationships to extend to lower trust contexts and enabling completely new applications. Does immutability make sense in that context? Depending on the specific business case, it will be necessary to allow transactions to be reversed on the chain. One can imagine a blockchain tracking real-world ownership. Then it would be essential that some (perhaps the courts of law) have the ability to change ownership on-chain. Otherwise a thief could steal someone’s house by hacking into their computer. Obviously that would have to be prevented.&lt;/p&gt;

&lt;p&gt;The great thing about permissioned chains is that who is allowed to do that can be set up at the beginning. Is is a capabilities-based approach. Thus one could assign a court of law and the asset registry the ability to cosign an ownership transfer.&lt;/p&gt;

&lt;p&gt;However, it is clearly preferable if in this case an additional transaction was created as opposed to any record of the previous transaction being erased. The latter would not prevent a corrupt regime from forging ownership records. The former would also not prevent corrupt governments from forging ownership, nothing really could, but it would create a transparent trace of what happened. This could even include the signatures of the officials responsible.&lt;/p&gt;

&lt;p&gt;I think this applies to any case where we care about auditability, which seems to be the case whenever we care about having process assurance. Therefore, immutability is of critical importance when smart-contract enabled blockchains are used for process assurance.&lt;/p&gt;

&lt;h1&gt;UTXOs versus blockchains with state&lt;/h1&gt;

&lt;p&gt;In this post, I didn’t look at the technical aspects of immutability. I’ve differentiated between permissioned and permissionless chains, but another key distinction is between blockchains like Bitcoin that do not have state and smart-contract blockchains that have a state. In the case of Bitcoin, preventing a reorganization of the blockchain is an essential security concern. But in the case of a smart contract chain, we can distinguish between a transaction log (which only has utility as a forensic tool) and the state of the contracts, which is what actually matters to do transactions.&lt;/p&gt;

&lt;p&gt;While it’s still unclear where blockchains, whatever their type, will eventually have the biggest impact, having a timestamped and cryptographically verified transaction log will be critical for most applications. This is not an aspect where permissioned and permissionless chains differ.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Eris CLI Tool Walkabout: Services</title>
      <link>http://localhost/2015/08/05/eris-services/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2015/08/05/eris-services/</guid>
      <description>

&lt;p&gt;{% include series.html %}&lt;/p&gt;

&lt;h2 id=&#34;services-as-a-service&#34;&gt;Services as a Service&lt;/h2&gt;

&lt;p&gt;Services are what you, as a developer, stitch together to build an application. They are the glue that holds everything together, run in docker containers, and can be built on top of other services.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say you want a blockchain to manage and automate an army of 3d printers. Your service, call it &lt;code&gt;three-dee-printing&lt;/code&gt;, might index CAD files as IPFS objects, each with a bitcoin address and price. A tendermint chain listening for (valid - i.e., paid in full) transactions to those bitcoin addresses could initiate printing by pulling the CAD image from IPFS and adding the print job to the queue. Users could upload any CAD file to your service to get a quote, after which it would be added to the index. There isn&amp;rsquo;t much left for you to do other than ensure your printers are running smoothly.&lt;/p&gt;

&lt;p&gt;The service definition file for &lt;code&gt;three-dee-printing&lt;/code&gt; would have this extra line:&lt;/p&gt;
[services]
dependencies = [&#34;ipfs&#34;, &#34;btcd&#34;, &#34;chainName&#34;]

&lt;p&gt;where &lt;code&gt;chainName&lt;/code&gt; is itself a chain running as a service. Yeah, it&amp;rsquo;s that easy. Of course, the bulk of the work goes into making contracts for your chain to manage the process.&lt;/p&gt;

&lt;p&gt;Perhaps Alice operates an army of delivery drones in the warehouse next door. She could have a service that has &lt;code&gt;three-dee-printing&lt;/code&gt; as a dependency and listens for transactions where the user has requested and paid for drone delivery. From order to delivery, services can do it all.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a neat example. What&amp;rsquo;s your service?&lt;/p&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eris-ltd/eris-cli/tree/develop#install-eris&#34; target=&#34;_blank&#34;&gt;Install Eris CLI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Read the &lt;a href=&#34;https://github.com/eris-ltd/eris-cli/tree/develop#services&#34; target=&#34;_blank&#34;&gt;README&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Run&lt;/p&gt;
eris init

&lt;p&gt;to grab some default service definition files.&lt;/p&gt;

&lt;p&gt;Find out which services are available&lt;/p&gt;
eris services known

&lt;p&gt;Launch a service&lt;/p&gt;
eris services start [name]

&lt;p&gt;Docker will do its thing and voila! Your service is running.&lt;/p&gt;

&lt;p&gt;Confirm this is the case&lt;/p&gt;
eris services ls

&lt;p&gt;Run a Bitcoin node: &lt;code&gt;btcd&lt;/code&gt;, or an ethereum node &lt;code&gt;eth&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Learn more about IPFS as a service &lt;a href=&#34;https://eng.erisindustries.com/tutorials/2015/08/05/ipfs-as-a-service/&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Starting a service can also spawn a data container if &lt;code&gt;data_container = true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;See &lt;a href=&#34;https://github.com/eris-ltd/eris-cli/tree/develop#data&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt; for more information about &lt;code&gt;eris data&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Protip: Running too many services at once might crash you operating system: kill a service&lt;/p&gt;
eris services stop [name]

&lt;p&gt;Add the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt; flags to get rid of the data containers and containers, respectively. When things really get bloated, run&lt;/p&gt;
docker rm -v -f $(docker ps -a -q)

&lt;p&gt;but be careful with this command.&lt;/p&gt;

&lt;p&gt;Note to OSX users - save yourself a lot of headache by working on a remote box or use Kitematic.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>