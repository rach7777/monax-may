<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
&lt;?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Command Line on Monax Industries</title>
    <link>http://localhost/tags/command-line/</link>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Sep 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost/tags/command-line/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Eris CLI Chains Walkabout: New</title>
      <link>http://localhost/2015/09/06/introing-eris-chains/</link>
      <pubDate>Sun, 06 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2015/09/06/introing-eris-chains/</guid>
      <description>&lt;p&gt;{% include series.html %}&lt;/p&gt;

&lt;p&gt;We, surprisingly, keep getting inbound communcation which queries why we are not &amp;ldquo;making&amp;rdquo; permissioned blockchains &amp;ldquo;any more&amp;rdquo;. This is surprising to me for two reasons, the first is because many folks seemed to utterly detest the &lt;em&gt;idea&lt;/em&gt; of permissioned blockchains at all. Full Stop. We called this, in the spring, (internally) the great blockchains war. It wasn&amp;rsquo;t really a war to us at all. We do not view permissioned or unpermissioned chains as competitors of one another any more than we view Cassandra and Mongo as competitors of one another. While both exist in the generalized database space, they are very different tools for very different things. Yet, despite the perspective that these are different tools to accomplish different purposes, folks seemed to get very religious about their blockchain designs and feel very passionate about one chain design vis a vis another. At Eris we are not religious about our blockchain designs.&lt;/p&gt;

&lt;p&gt;The second reason that this inbound is surprising to me, is that we haven&amp;rsquo;t actually stopped making permissioned blockchains. We have &lt;strong&gt;continued our work&lt;/strong&gt; in the permissioned blockchain (really, permissioned smart contract network) space only we are doing so in collaboration with the Tendermint open source project rather than under the Eris namespace. Almost all of the learning and effort which we put into crafting thelonious has been captured, improved, and reworked into the Tendermint project&amp;rsquo;s blockchain design. Indeed, that blockchain is fully permissionable out of the box due to our efforts and what we learned while building thelonious.&lt;/p&gt;

&lt;p&gt;Lastly, I&amp;rsquo;d like to remind folks that the &lt;code&gt;eris&lt;/code&gt; tool is &lt;strong&gt;optimized for working with permissioned smart contract networks&lt;/strong&gt;. It does run public blockchains out of the box, and for those that want to run public blockchains which we do not have a service definition file built for, it is as easy as making sure that the blockchain in question has a Docker image and making a service definition file for it (which is usually only a few lines).&lt;/p&gt;

&lt;p&gt;So, how does &lt;code&gt;eris&lt;/code&gt; work with permissioned smart contract networks? In general it provides some very convenient wrapping around the &lt;code&gt;eris chain manager&lt;/code&gt; scripts which we make sure to compile into the the &lt;code&gt;eris/erisdb&lt;/code&gt; Docker image (for more on Docker see the &lt;a href=&#34;https://eng.erisindustries.com/tutorials/2015/09/05/docker-and-eris/&#34; target=&#34;_blank&#34;&gt;Eris CLI Walkabout post on Docker&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;This post will speak to &lt;code&gt;eris chains new&lt;/code&gt; which is how &lt;code&gt;eris&lt;/code&gt; supports hashing a new permissioned smart contract network.&lt;/p&gt;

&lt;p&gt;When one does &lt;code&gt;eris chains new test_chain&lt;/code&gt; then what eris will do, if no flags are given, is to read the default chain configuration files from &lt;code&gt;~/.eris/chains/config/default&lt;/code&gt; and hash a new chain it will call &lt;code&gt;test_chain&lt;/code&gt;. These default configuration files are written to the host hard drive (in the location noted above) during the &lt;code&gt;eris init&lt;/code&gt; process.&lt;/p&gt;

&lt;p&gt;Once the files have been copied into a data container, then eris is ready to start a service which will hash the blockchain into existence. To do this we use the &lt;code&gt;eris/erisdb&lt;/code&gt; container with the volumes from the data container mounted. This separates out the data which the process will run against from the actual operation process (computational sequence) itself.&lt;/p&gt;

&lt;p&gt;When the chain has been hashed, then it will not be started and the service container will be removed, leaving &lt;strong&gt;only&lt;/strong&gt; a container which will likely look something like this: &lt;code&gt;eris_data_test_chain_1&lt;/code&gt;. If you do &lt;code&gt;docker ps -a&lt;/code&gt; after running &lt;code&gt;eris chains new test_chain&lt;/code&gt; this is likely all you will see. We have an issue open to change this default so that after a chain is hashed then the chain starts running, but for now that is not the default behaviour.&lt;/p&gt;

&lt;p&gt;So if you do &lt;code&gt;eris chains ls&lt;/code&gt; after doing &lt;code&gt;eris chains new test_chain&lt;/code&gt; you will not actually see a chain. This is expected behaviour because what &lt;code&gt;eris chains ls&lt;/code&gt; will do is to read from docker the existing chain type containers, but there will not be any chain type containers (unless you have other chains) at this point. In order to start running the chain you just created you will type &lt;code&gt;eris chains start test_chain&lt;/code&gt;. This will create the running service container and use the &lt;code&gt;test_chain&lt;/code&gt; data container. Once you have started the chain running if you do &lt;code&gt;eris chains ls&lt;/code&gt; again you will see &lt;code&gt;test_chain&lt;/code&gt; there.&lt;/p&gt;

&lt;p&gt;Now, you will not always want to have the chain be hashed with the default configuration (which we make sure is available only for quick test chains and it should &lt;strong&gt;never&lt;/strong&gt; be used for non-test chains). To create a chain which you would want to use for your application, rather than simply for quick testing, you will want to update the config files appropriately. To do this, the easiest way to start is to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp -r ~/.eris/chains/config/default ~/.eris/chains/config/mychain14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will copy the default configuration files into a new directory. At this point open the default configuration files in your text editor and edit them as necessary for your setup. At the end then you will do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eris chains new mychain14 --dir ~/.eris/chains/config/mychain14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the &lt;code&gt;--dir&lt;/code&gt; flag is given to chains new, it will read the configuration files from that directory rather than the &lt;code&gt;~/.eris/chains/config/default&lt;/code&gt; and use those instead of the default configuration files when hashing the new chain. For an even more lightweight solution you can give it a genesis.json and or a set of validator.csv and accounts.csv files to use via different flags. There will be another onboarding post about these files coming soon.&lt;/p&gt;

&lt;p&gt;If you have any questions about the chains hashing process please do not hestitate to visit our &lt;a href=&#34;https://support.erisindustries.com&#34; target=&#34;_blank&#34;&gt;forums&lt;/a&gt; or leave a comment below and we will try to answer as quickly as we can.&lt;/p&gt;

&lt;p&gt;Happy (permissioned) blockchaining!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Eris CLI Walkabout: Docker &amp; Execution</title>
      <link>http://localhost/2015/09/05/docker-and-eris/</link>
      <pubDate>Sat, 05 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2015/09/05/docker-and-eris/</guid>
      <description>&lt;p&gt;{% include series.html %}&lt;/p&gt;

&lt;p&gt;Docker is a bit of a strange cat for folks who are just getting up to speed. Many people when they&amp;rsquo;re getting started with Docker think of it in terms of a &amp;ldquo;Virtual Machine&amp;rdquo; as many are used to this idea of execution being constrained into a &amp;ldquo;virtualized&amp;rdquo; environment. The problem is that Docker is not a virtual machine. Indeed, it is a very different animal entirely than virtual machines.&lt;/p&gt;

&lt;p&gt;Virtual machines are a mechanism to provide an isolated interface to a computer where the isolated interface runs an entire OS. That OS is booted from the start and then operates just as if it was the primary operating system on the machine although its &amp;ldquo;connection&amp;rdquo; to the hardware that exists on the computer is mediated by VirtualBox, VMWare, Xen or one of the other virtualization software suites.&lt;/p&gt;

&lt;p&gt;The basic idea (and, for us, the appeal) of using &lt;strong&gt;both&lt;/strong&gt; virtual machines &lt;strong&gt;and&lt;/strong&gt; containers, is that programs are able to get started in a consistent manner. Because we are building &lt;code&gt;eris&lt;/code&gt; to be runnable in a wide variety of situations from large cloud deployments to laptops and many iterations in between, we want to be able to provide users with a harmonized experience across those operating systems. This is an old goal in programming, but because of the large differences across operating systems and host environments there are approximately an infinite amount of edge cases which raise challenges for creating software. Were we a company the size of Microsoft or Oracle then I could tell the platform team to just build natively for each major operating system and be done with it. But we have four engineers at Eris. Yet building a system which can consistently run across a wide variety of host environments &lt;strong&gt;is possible&lt;/strong&gt; because of what Docker and virtual machines offer us.&lt;/p&gt;

&lt;p&gt;Docker is a &amp;ldquo;containerized&amp;rdquo; system where individual &lt;em&gt;processes&lt;/em&gt; are isolated and given direct (unmediated) access to the Kernel according to the terms which Docker allows when a container is started. There is a lot of detail required to fully understand the difference between a full virtual machine and containers (some answers available &lt;a href=&#34;http://stackoverflow.com/a/16048358&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://www.docker.com/whatisdocker&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;) but the basic way that I think about it is that containers are isolated processes running within a Linux operating system whereas virtual machines are isolated operating systems.&lt;/p&gt;

&lt;p&gt;To summarize the links above, the major difference(s) between containers and virtual machines gets at what is actually &amp;ldquo;shared&amp;rdquo; between the host (or other containers) and the running executable inside the isolated environment. A virtual machine isolates the &lt;strong&gt;entire&lt;/strong&gt; operating system. This means that virtual machine images are routinely 1-10GB large and each of them is unique (in other words the host must hold 1-10GB X however many VMs it is operating). On the other hand, Docker containers are built as minimal viable operating processes and as such are usually smaller in size. Containers are able to share a significant amount of their file structure across containers on a single host. But more importantly than having the actual images smaller is &lt;em&gt;how the images are built&lt;/em&gt;. Docker builds its images in layers and when one does &lt;code&gt;docker pull&lt;/code&gt; or &lt;code&gt;docker push&lt;/code&gt; what Docker actually does behind the scenes is to reconcile each of these layers as individual layers. Docker also reuses parts of images across containers.&lt;/p&gt;

&lt;p&gt;So what does this mean? At eris we build almost all of our core images as addendums to the &lt;code&gt;eris/base&lt;/code&gt; image. The &lt;code&gt;eris/base&lt;/code&gt; image is a jessie based image. It does no more than make sure that go is installed and have an eris user built. At the time of this writing, the &lt;code&gt;eris/base&lt;/code&gt; image weighs in at 519.1MB.&lt;/p&gt;

&lt;p&gt;To build data containers we have an &lt;code&gt;eris/data&lt;/code&gt; image. This image is &lt;code&gt;FROM eris/base&lt;/code&gt; and then it establishes a volume which will be used to store data from an operational container. The &lt;code&gt;eris/data&lt;/code&gt; container is also 519.1MB. But when one downloads from Docker the &lt;code&gt;eris/base&lt;/code&gt; image AND the &lt;code&gt;eris/data&lt;/code&gt; image, one will not have to download 519.1MB X2 but rather 519.1MB X1. While it is not ideal that one would have to download 519.1MB at all, it is necessary to get going providing users with a harmonized, isolated environment for running distributed applications.&lt;/p&gt;

&lt;p&gt;Compare this to the &lt;code&gt;eris/ipfs&lt;/code&gt; image which is 572.7MB big. It is also built &lt;code&gt;FROM eris/base&lt;/code&gt; so when a user downloads the &lt;code&gt;eris/ipfs&lt;/code&gt; container, but already had downloaded the &lt;code&gt;eris/base&lt;/code&gt; container, one will only have to download the extra layers which comprise only the ipfs executable and a small start script, or 52.6MB. Go binaries tend to be a bit bigger than other compiled languages because Go compiles the runtime into the binary. That said, 52.6MB is not that large for all the functionality one gets from the IPFS container.&lt;/p&gt;

&lt;p&gt;Similarly, if one has downloaded the &lt;code&gt;eris/ipfs&lt;/code&gt; image and wants to start it, by default &lt;code&gt;eris&lt;/code&gt; will want also start a container based off of the &lt;code&gt;eris/data&lt;/code&gt; image, but since the &lt;code&gt;eris/data&lt;/code&gt; image and the &lt;code&gt;eris/ipfs&lt;/code&gt; image are both &lt;code&gt;FROM eris/base&lt;/code&gt; then there is not really anything (other than a simple establish the volume command) which docker will download when the &lt;code&gt;eris/ipfs&lt;/code&gt; and &lt;code&gt;eris/data&lt;/code&gt; images are used to start containers.&lt;/p&gt;

&lt;p&gt;Right. So with that background in mind. How does Eris interact with Docker and how does Docker interact with the operating system. Let us first take a look at the overall operall design of &lt;code&gt;eris&lt;/code&gt; the tool:&lt;/p&gt;

&lt;p&gt;{{ page.date | date: &amp;ldquo;%Y&amp;rdquo; | append:&amp;lsquo;/eris-docker-overview.png&amp;rsquo; | img }}&lt;/p&gt;

&lt;p&gt;Eris connects to both a Host&amp;rsquo;s harddrive (usually in the &lt;code&gt;~/.eris&lt;/code&gt; directory is where we keep all of our files needed to run and interact with various distributed applications) as well as a Docker daemon. That Docker daemon then interacts with the (Linux only) operating system. To be a bit more precise what is happening looks like this:&lt;/p&gt;

&lt;p&gt;{{ page.date | date: &amp;ldquo;%Y&amp;rdquo; | append:&amp;lsquo;/eris-docker-kernel.png&amp;rsquo; | img }}&lt;/p&gt;

&lt;p&gt;Docker is really only able to interact with a Linux kernel. This means that for users who are on Windows or OSX they will need to have a Linux based virtual machine with Docker attached to it. We strongly recommend to folks that they use the &lt;a href=&#34;https://www.docker.com/toolbox&#34; target=&#34;_blank&#34;&gt;Docker Toolbox&lt;/a&gt; which will install everything needed to create Docker only virtual machines (which basically are just a Kernel and a Docker daemon and as such are very small and lightweight) on local or remote boxes. If users run Linux natively on the host running Docker in a virtual machine is fine as is running Docker on the host and connecting into the Daemon that way. Eris will connect to Docker either via an https connection if Docker is running in a virtual machine (whatever the host OS is) or over unix sockets if Docker is running on the Host.&lt;/p&gt;

&lt;p&gt;Finally, when this is all put together it looks something like this:&lt;/p&gt;

&lt;p&gt;{{ page.date | date: &amp;ldquo;%Y&amp;rdquo; | append:&amp;lsquo;/eris-docker-details.png&amp;rsquo; | img }}&lt;/p&gt;

&lt;p&gt;Of course the Linux Kernel in the above image &lt;strong&gt;may&lt;/strong&gt; be running inside a very lightweight virtual machine &lt;strong&gt;or&lt;/strong&gt; directly on the host, depending on how one is set up.&lt;/p&gt;

&lt;p&gt;The other big learning curve for new users to Docker is the differences between &lt;code&gt;images&lt;/code&gt; and &lt;code&gt;containers&lt;/code&gt;. This is a bit easier to communicate so I&amp;rsquo;ve left it for the end. Docker images are immutable layers of files which define how an isolate process should run. Containers, on the other hand, are the running process itself. Containers, once started, cannot be &amp;ldquo;changed&amp;rdquo; in the sense of what ports they are given access to, what their starting sequence command is supposed to be etc. They can be stopped, started, paused, unpaused, etc. But they cannot change too much of what they can do other than their state in terms of being &amp;ldquo;on&amp;rdquo; or &amp;ldquo;off&amp;rdquo;. For example, to open a new port from the host to a container, one would have to remove the container and make a new container with a new process. Although with &lt;code&gt;eris&lt;/code&gt; we are able to abstract most of this from the user via our service definition files paradigm along with &lt;code&gt;eris services update&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Hope this has helped you understand a bit of the vagaries and nuances of how to work with Docker. Please let us know if you have any questions either on our &lt;a href=&#34;https://support.erisindustries.com&#34; target=&#34;_blank&#34;&gt;forums&lt;/a&gt; or in the comments below.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Eris CLI Services Walkabout: BTCD</title>
      <link>http://localhost/2015/09/01/btcd-as-a-service/</link>
      <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2015/09/01/btcd-as-a-service/</guid>
      <description>

&lt;p&gt;{% include series.html %}&lt;/p&gt;

&lt;p&gt;We got a question recently on the &lt;a href=&#34;https://support.erisindustries.com/support/discussions/topics/6000011734&#34; target=&#34;_blank&#34;&gt;forum&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;So just to be clear if I wanted to mine with that [btcd] node (and I don&#39;t) what would I configure? Not the service definition file right? Bitcoind has the .conf file and it has commands. When I want to mine using btcd (or mine my test chain) where is this determined?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hope the asker doesn&amp;rsquo;t mind that I answer here as answering these questions could help a lot of people.&lt;/p&gt;

&lt;h2 id=&#34;where-to-start-when-investigating-a-service&#34;&gt;Where To Start When Investigating a Service&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Look at the &lt;a href=&#34;https://github.com/eris-ltd/common/blob/master/docker/btcd/Dockerfile&#34; target=&#34;_blank&#34;&gt;Dockerfile&lt;/a&gt; (that link is to the dockerfile for eris/btcd).&lt;/li&gt;
&lt;li&gt;Look at the start script (if there is one).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Generally Docker images come in two flavours. They have a start script which manages their start sequence. &lt;strong&gt;Or&lt;/strong&gt;. They get started using a config pulled from config files (which means we have to get the config files &amp;ldquo;into&amp;rdquo; the containers). Taking a look at the &lt;code&gt;CMD&lt;/code&gt; or &lt;code&gt;ENTRYPOINT&lt;/code&gt; in the Dockerfile is usually a dead giveaway, if not sometimes more investigation is necessary.&lt;/p&gt;

&lt;p&gt;To investigate farther with &lt;code&gt;eris&lt;/code&gt; built Docker images for services we aren&amp;rsquo;t building, we keep all of these in our &lt;a href=&#34;https://github.com/eris-ltd/common/&#34; target=&#34;_blank&#34;&gt;Eris commons&lt;/a&gt; in the &lt;code&gt;docker&lt;/code&gt; folder. Compare the &lt;code&gt;btcd&lt;/code&gt; folder to the &lt;code&gt;eth&lt;/code&gt; folder if you would like to see a typical start script.&lt;/p&gt;

&lt;p&gt;Since btcd doesn&amp;rsquo;t use a start script we&amp;rsquo;ll save that for another day (Ethan and I now both love shell scripting, well at least I certainly do).&lt;/p&gt;

&lt;h2 id=&#34;if-a-service-starts-with-config-files-what-do-i-do&#34;&gt;If a Service Starts With Config Files What Do I Do?&lt;/h2&gt;

&lt;p&gt;The asker of the original question is right, the &lt;code&gt;btcd&lt;/code&gt; container starts with a config file instead of via the other major &amp;ldquo;Docker way&amp;rdquo; which is a bunch of environment variables passed into a semi-intelligent start script which preconfigures and then runs a binary (for an example of this see Ethan&amp;rsquo;s &lt;a href=&#34;https://github.com/eris-ltd/eris-db/tree/master/DOCKER&#34; target=&#34;_blank&#34;&gt;eris chain manager scripts&lt;/a&gt; which we use for &lt;code&gt;eris chains&lt;/code&gt;). &lt;code&gt;btcd&lt;/code&gt; uses a config file.&lt;/p&gt;

&lt;p&gt;This is where having an understanding of how &lt;code&gt;eris&lt;/code&gt; manages data containers becomes important.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eris data&lt;/code&gt; is a pretty powerful tool when it is used correctly. What we do with data containers is that we keep a folder in the host&amp;rsquo;s file system at &lt;code&gt;~/.eris/data/NAME&lt;/code&gt; (where &lt;code&gt;NAME&lt;/code&gt; is the name of a service or chain). In that folder you can put whatever files are needed to start a specific &amp;ldquo;program&amp;rdquo; (which will usually be a container). Then you can run &lt;code&gt;eris data import NAME --dest PATH&lt;/code&gt; to &amp;ldquo;put&amp;rdquo; &lt;strong&gt;whatever is in the host location&lt;/strong&gt; &amp;ldquo;into&amp;rdquo; the containers at the &lt;code&gt;--dest&lt;/code&gt; you tell it. (Note, for pure eris programs we use the &lt;code&gt;~/.eris&lt;/code&gt; inside the containers so if you&amp;rsquo;re importing into an erisdb container, for instance, &lt;code&gt;--dest&lt;/code&gt; is not necessary cause automagic.)&lt;/p&gt;

&lt;p&gt;Later, if you want to &amp;ldquo;get&amp;rdquo; files &amp;ldquo;out&amp;rdquo; of the container you will &lt;code&gt;eris data export NAME --src PATH&lt;/code&gt; (again, for eris proper containers, like erisdb, this is unnecessary cause automagic). That command will take whatever is in the volumes of the data container and export them to the host so that you can change them.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s put this together to talk through how to start &lt;code&gt;btcd&lt;/code&gt; with a custom configuration.&lt;/p&gt;

&lt;h2 id=&#34;steps-to-success&#34;&gt;Steps to Success&lt;/h2&gt;

&lt;h3 id=&#34;step-1-eris-services-start-btcd&#34;&gt;Step (1): &lt;code&gt;eris services start btcd&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;First, start the node. This will make it drop its default configuration files in the right location. There is no output here if the command ran correctly.&lt;/p&gt;

&lt;h3 id=&#34;step-2-eris-services-ls&#34;&gt;Step (2): &lt;code&gt;eris services ls&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Second, check that the node is running. I currently have ipfs running so my output looks like this:&lt;/p&gt;
 SERVICE NAME     CONTAINER NAME       TYPE     CONTAINER #                                           PORTS
-------------- --------------------- --------- ------------- ----------------------------------------------------------------------------------------
 btcd           eris_service_btcd_1   service   1             18332/tcp 18333/tcp 18334/tcp 8332/tcp 0.0.0.0:8333-&gt;8333/tcp 0.0.0.0:8334-&gt;8334/tcp
 ipfs           eris_service_ipfs_1   service   1             0.0.0.0:4001-&gt;4001/tcp 0.0.0.0:5001-&gt;5001/tcp 0.0.0.0:8080-&gt;8080/tcp

&lt;p&gt;A note about the listing commands. For services (and chains) there are three different listing commands:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;eris services known&lt;/code&gt; will simply read the files in the target folder. In other words your *definition_files. It does not tell you anything about the containers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eris services ls&lt;/code&gt; will simply tell you which containers &lt;em&gt;exist&lt;/em&gt; (they may or may not be running).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eris services ps&lt;/code&gt; will simply tell you which containers &lt;em&gt;are running&lt;/em&gt; (and exist of course).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step-3-eris-services-stop-btcd&#34;&gt;Step (3): &lt;code&gt;eris services stop btcd&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Stop the node. There is no output here if the command was successful.&lt;/p&gt;

&lt;p&gt;Run &lt;code&gt;eris services ps&lt;/code&gt; to confirm it stopped by comparing that output to &lt;code&gt;eris services ls&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;step-4-eris-data-ls&#34;&gt;Step (4): &lt;code&gt;eris data ls&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This will check that the data container was made.&lt;/p&gt;

&lt;h3 id=&#34;step-5-eris-data-export-btcd-src-home-eris-btcd&#34;&gt;Step (5): &lt;code&gt;eris data export btcd --src /home/eris/.btcd&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This will perform the export of the volumes talked about above. How did I know what source directory? From the &lt;code&gt;VOLUMES&lt;/code&gt; line in the dockerfile.&lt;/p&gt;

&lt;h3 id=&#34;step-6-cd-eris-data-btcd-ls-la&#34;&gt;Step (6): &lt;code&gt;cd ~/.eris/data/btcd/ &amp;amp;&amp;amp; ls -la&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This will move into the data directory and show you what was exported. (Note you may have some permissions errors depending on your setup, but since its in the user&amp;rsquo;s folder it should be overcomeable).&lt;/p&gt;

&lt;p&gt;You should see a &lt;code&gt;.btcd&lt;/code&gt; directory now. When I exported there was no conf file there (after a bit of investigation I realized that btcd doesn&amp;rsquo;t actually drop a config file). That&amp;rsquo;s fine, we can create one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;touch ~/.eris/data/btcd/.btcd/btcd.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also edit it however you want in whatever text editor you prefer according to the specification which btcd uses for its config files.&lt;/p&gt;

&lt;h3 id=&#34;step-7-eris-data-import-btcd-dest-home-eris&#34;&gt;Step (7): &lt;code&gt;eris data import btcd --dest /home/eris&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;One thing to note here is that the paths are (slightly) different on the import than they were on the export. The exported volume was the .btcd path &amp;ldquo;inside&amp;rdquo; the container. That gave us the &lt;code&gt;~/.eris/data/btcd/&lt;/code&gt;&lt;strong&gt;&lt;code&gt;.btcd&lt;/code&gt;&lt;/strong&gt; on the host. But when we import from the host &amp;ldquo;into&amp;rdquo; the container we want to put the &lt;code&gt;.btcd&lt;/code&gt; directory into the &lt;code&gt;~&lt;/code&gt; directory so that the result inside the containers is &lt;code&gt;~/.btcd&lt;/code&gt; using a different path for the &lt;code&gt;--src&lt;/code&gt; and &lt;code&gt;--dest&lt;/code&gt; will accomplish this and will properly &amp;ldquo;align&amp;rdquo; the files in the right place inside the conter.&lt;/p&gt;

&lt;h3 id=&#34;step-8-eris-services-start-btcd&#34;&gt;Step (8): &lt;code&gt;eris services start btcd&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Now your chain should boot with your custom config file.&lt;/p&gt;

&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;eris&lt;/code&gt; isn&amp;rsquo;t optimized for btcd like containers. It fully runs them, but it does take a bit of work to get set up with containers that us a config file instead of being having a bootable config passed in as environment variables. In general we are of the opinion that start scripts and environment files go further than config files for configuring how things run in containers.&lt;/p&gt;

&lt;p&gt;How could this be improved? Well, for one a start script that would recieve the relevant env vars and dump those into a config before starting btcd would go a long way. We haven&amp;rsquo;t had time to do that yet, but as they say&amp;hellip;. pull requests welcome.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Eris CLI Services Walkabout: IPFS</title>
      <link>http://localhost/2015/08/05/ipfs-as-a-service/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2015/08/05/ipfs-as-a-service/</guid>
      <description>

&lt;p&gt;{% include series.html %}&lt;/p&gt;

&lt;p&gt;Part 1 explains &lt;code&gt;eris files&lt;/code&gt;; the command for working with IPFS.&lt;/p&gt;

&lt;p&gt;Part 2 highlights additional IPFS integrations in the Eris stack.&lt;/p&gt;

&lt;h2 id=&#34;part-1-eris-files&#34;&gt;Part 1: eris files&lt;/h2&gt;

&lt;p&gt;Hello &lt;a href=&#34;https://ipfs.io/&#34; target=&#34;_blank&#34;&gt;IPFS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;With IPFS &lt;a href=&#34;https://eng.erisindustries.com/tutorials/2015/08/05/eris-services/&#34; target=&#34;_blank&#34;&gt;running as a service&lt;/a&gt;, access IPFS&lt;/p&gt;
eris files

&lt;p&gt;Check out the webui at &lt;code&gt;http://yourhost:5001/webui&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Add a file to IPFS&lt;/p&gt;
eris files put [fileName]

&lt;p&gt;It&amp;rsquo;s hash is returned and you can now view its contents through either your nodes&amp;rsquo; webui or through the gateway.&lt;/p&gt;

&lt;p&gt;Download a file from IPFS&lt;/p&gt;
eris files get [fileHash] [fileName]

&lt;p&gt;where &lt;code&gt;[fileName]&lt;/code&gt; is a new file name for the contents, to be saved in your working directory.&lt;/p&gt;

&lt;p&gt;Want to keep the file around as an IPFS object? (otherwise it&amp;rsquo;ll garbage collect)&lt;/p&gt;
eris files cache [hash]

&lt;p&gt;All that caching you did, what files are hanging around?&lt;/p&gt;
eris files cached

&lt;p&gt;Look inside a recusively added directory&lt;/p&gt;
eris files ls [objectHash]

&lt;p&gt;There you have it; &lt;code&gt;eris files&lt;/code&gt; in five commands.&lt;/p&gt;

&lt;h2 id=&#34;other-ipfs-integrations-in-the-eris-stack&#34;&gt;Other IPFS integrations in the Eris stack&lt;/h2&gt;

&lt;h3 id=&#34;import-export-service-definition-files-from-to-ipfs&#34;&gt;import/export service definition files from/to IPFS&lt;/h3&gt;
eris services import/export

&lt;p&gt;This is useful for sharing custom service definition files.&lt;/p&gt;

&lt;h3 id=&#34;mintdump&#34;&gt;mintdump&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/eris-ltd/mint-client&#34; target=&#34;_blank&#34;&gt;mint client&lt;/a&gt; is used for managing &lt;a href=&#34;https://erisindustries.com/components/erisdb&#34; target=&#34;_blank&#34;&gt;eris:db&lt;/a&gt; chains.
Dump the chain state to IPFS&lt;/p&gt;
mintdump dump --ipfs

&lt;p&gt;returns an IPFS hash on stdout&lt;/p&gt;

&lt;p&gt;Restore a chain&lt;/p&gt;
mintdump restore [new_chain_name] --ipfs=&#34;fileHash&#34;

&lt;p&gt;where &lt;code&gt;fileHash&lt;/code&gt; is the output from &lt;code&gt;dump&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Eris CLI Tool Walkabout: Services</title>
      <link>http://localhost/2015/08/05/eris-services/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2015/08/05/eris-services/</guid>
      <description>

&lt;p&gt;{% include series.html %}&lt;/p&gt;

&lt;h2 id=&#34;services-as-a-service&#34;&gt;Services as a Service&lt;/h2&gt;

&lt;p&gt;Services are what you, as a developer, stitch together to build an application. They are the glue that holds everything together, run in docker containers, and can be built on top of other services.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say you want a blockchain to manage and automate an army of 3d printers. Your service, call it &lt;code&gt;three-dee-printing&lt;/code&gt;, might index CAD files as IPFS objects, each with a bitcoin address and price. A tendermint chain listening for (valid - i.e., paid in full) transactions to those bitcoin addresses could initiate printing by pulling the CAD image from IPFS and adding the print job to the queue. Users could upload any CAD file to your service to get a quote, after which it would be added to the index. There isn&amp;rsquo;t much left for you to do other than ensure your printers are running smoothly.&lt;/p&gt;

&lt;p&gt;The service definition file for &lt;code&gt;three-dee-printing&lt;/code&gt; would have this extra line:&lt;/p&gt;
[services]
dependencies = [&#34;ipfs&#34;, &#34;btcd&#34;, &#34;chainName&#34;]

&lt;p&gt;where &lt;code&gt;chainName&lt;/code&gt; is itself a chain running as a service. Yeah, it&amp;rsquo;s that easy. Of course, the bulk of the work goes into making contracts for your chain to manage the process.&lt;/p&gt;

&lt;p&gt;Perhaps Alice operates an army of delivery drones in the warehouse next door. She could have a service that has &lt;code&gt;three-dee-printing&lt;/code&gt; as a dependency and listens for transactions where the user has requested and paid for drone delivery. From order to delivery, services can do it all.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a neat example. What&amp;rsquo;s your service?&lt;/p&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eris-ltd/eris-cli/tree/develop#install-eris&#34; target=&#34;_blank&#34;&gt;Install Eris CLI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Read the &lt;a href=&#34;https://github.com/eris-ltd/eris-cli/tree/develop#services&#34; target=&#34;_blank&#34;&gt;README&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Run&lt;/p&gt;
eris init

&lt;p&gt;to grab some default service definition files.&lt;/p&gt;

&lt;p&gt;Find out which services are available&lt;/p&gt;
eris services known

&lt;p&gt;Launch a service&lt;/p&gt;
eris services start [name]

&lt;p&gt;Docker will do its thing and voila! Your service is running.&lt;/p&gt;

&lt;p&gt;Confirm this is the case&lt;/p&gt;
eris services ls

&lt;p&gt;Run a Bitcoin node: &lt;code&gt;btcd&lt;/code&gt;, or an ethereum node &lt;code&gt;eth&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Learn more about IPFS as a service &lt;a href=&#34;https://eng.erisindustries.com/tutorials/2015/08/05/ipfs-as-a-service/&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Starting a service can also spawn a data container if &lt;code&gt;data_container = true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;See &lt;a href=&#34;https://github.com/eris-ltd/eris-cli/tree/develop#data&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt; for more information about &lt;code&gt;eris data&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Protip: Running too many services at once might crash you operating system: kill a service&lt;/p&gt;
eris services stop [name]

&lt;p&gt;Add the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt; flags to get rid of the data containers and containers, respectively. When things really get bloated, run&lt;/p&gt;
docker rm -v -f $(docker ps -a -q)

&lt;p&gt;but be careful with this command.&lt;/p&gt;

&lt;p&gt;Note to OSX users - save yourself a lot of headache by working on a remote box or use Kitematic.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>