<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
&lt;?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dao on Monax Industries</title>
    <link>http://localhost/tags/dao/</link>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 18 Jun 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost/tags/dao/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Fact Patterns, Predictions and Building Decentralized Organizations</title>
      <link>http://localhost/2016/06/18/fact-patterns-dao-legal-engineering/</link>
      <pubDate>Sat, 18 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2016/06/18/fact-patterns-dao-legal-engineering/</guid>
      <description>

&lt;p&gt;{{ page.date | date: &amp;ldquo;%Y&amp;rdquo; | append:&amp;lsquo;/crystal-ball.jpg&amp;rsquo; | img }}&lt;/p&gt;

&lt;h1 id=&#34;fact-patterns-predictions-and-building-decentralized-organizations&#34;&gt;Fact Patterns, Predictions and Building Decentralized Organizations&lt;/h1&gt;

&lt;p&gt;Yesterday was a noisy one in the smart contracts world. The ambitious early Ethereum project, The DAO, blew up overnight as token holders found their accounts drained by a hacker. The DAO was the first large, for profit, decentralized autonomous organization deployed on Ethereum’s public blockchain, attracting more than $150 million worth of ether investment in its crowdsale.&lt;/p&gt;

&lt;p&gt;The response of in the blockchain community has been a mixture of shock and “I told you so,” especially from lawyers. In smartcontractland, lawyers generally opined that The DAO iteration was too unstable for deployment and said so noisily in blogs and social media. The developers saw a bug, well in advance of release. The lawyers saw a different problem: the DAO loudly eschewed risk management because of the self-executing nature of smart contract code. Lawyers warned that risks for participants in the event of failure ranged from losing their investments to enormous civil liability and possibly jail. Undaunted, the DAO deployed anyway. Here be dragons indeed.&lt;/p&gt;

&lt;p&gt;Lawyers predicted the organization’s implosion based on their knowledge of &lt;em&gt;fact patterns&lt;/em&gt;, that is, the tendency of human relationships to repeat, in cause-and-effect succession, recorded over centuries by the legal system. Common law attorneys learn primarily by studying fact patterns of prior relationship failure to recognize recipes for disaster and avert course accordingly. Fact patterns allow lawyers to distance ourselves from the human stories that might otherewise cloud our analysis and judgment so we can make clearer decisions. In The DAO’s case, red flags were obvious: unlicensed actors in regulated space, refusal to plan for what might happen in the event of a failure and lack of testing. Lawyers also calmly accept that you just can’t convince some people, and the law will be there to both clean up the mess and tell us how to avoid the same problems in the future.&lt;/p&gt;

&lt;p&gt;Maybe it didn’t have to be this way, with a little attention to risk management and legal engineering. The same fact patterns that informed lawyers’ prediction of problems with The DAO give us models on which to build, to experiment, to push the limits of blockchain relationships. Risk management and legal engineering allow us to plan how we build according to the succession rules of “what might go wrong?” In legalese, it&amp;rsquo;s about &lt;em&gt;foreseeablility&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since inception, Eris has led the way on decentralized organization development. It&amp;rsquo;s one of the things that made me want to be a marmot, the company&amp;rsquo;s clear-eyed view on &amp;ldquo;how to&amp;rdquo; do DAO and its vision of the huge potential of DAO done right. As &lt;a href=&#34;https://prestonbyrne.com/2016/05/17/thedao-dont-walk-away-restructure/&#34; target=&#34;_blank&#34;&gt;Preston Byrne wrote recently&lt;/a&gt;, the blockchain decentralized organization model is worth fixing. Despite manifest risk, people around the globe poured money into The DAO project, demonstrating the traction of cryptographic code-based organizations bringing global actors together to achieve a purpose. The time for decentralized organizations is here. The DAO debacle is a testament to the crucial need to get corporate governance right and a test of the governance of Ethereum as a whole as it weighs its response.&lt;/p&gt;

&lt;p&gt;This post is not an “I told you so,” rather, it is an exploration of the value of the fact pattern in both making predictions and building stuff for human use. The DAO fact pattern reinforces these law school lessons: 1) blockchains, like all human undertakings, are not special snowflakes; and 2) the best way to change the law is to learn its rules and carefully direct their evolution, use case by use case. To build new models that humans use, we must study, and learn from, human fact patterns.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lessons on Preparation for Disaster from the DAO</title>
      <link>http://localhost/2016/06/18/lessons-learned-dao/</link>
      <pubDate>Sat, 18 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2016/06/18/lessons-learned-dao/</guid>
      <description>

&lt;p&gt;Much has been written about the fall of the DAO in the past 24 hours and there has been a lot of talk of what happened and what didn&amp;rsquo;t happen that should have happened. I&amp;rsquo;m not going to talk about how it happened. There are many colorful and wonderful pieces explaining the attack, one of which I recommend reading for this particular instance is &lt;a href=&#34;http://vessenes.com/deconstructing-thedao-attack-a-brief-code-tour/&#34; target=&#34;_blank&#34;&gt;Peter Vessenes&amp;rsquo;s&lt;/a&gt;
(And seriously subscribe to that blog if you&amp;rsquo;re developing smart contracts because that dude comes up with amazing and critical stuff that every solidity programmer should be made aware of).&lt;/p&gt;

&lt;p&gt;I am instead writing today to talk about how the DAO should have been written instead to prevent not only this security flaw, but any other security flaws inherent in it. As one of the core developers of the Solidity programming language itself, I also will be discussing some ideas from the team and the Ethereum community to prevent problems like the Reentry attack from occurring on a scale like this again.&lt;/p&gt;

&lt;h2 id=&#34;back-to-basics&#34;&gt;Back to Basics&lt;/h2&gt;

&lt;p&gt;Be very careful with how you write your code, and always test it first, and thoroughly. Unlike normal code, once this bugs up, it&amp;rsquo;s there permanently, unless you put in the ability to destroy the contract. The problem that caused this whole spat was one line of code. That&amp;rsquo;s right. ONE. LINE. OF. CODE.&lt;/p&gt;

&lt;p&gt;Here is the code that destroyed the DAO.&lt;/p&gt;
function payOut(address _recipient, uint _amount) returns (bool) {
        if (msg.sender != owner || msg.value &gt; 0 || (payOwnerOnly &amp;&amp; _recipient != owner))
            throw;
        if (_recipient.call.value(_amount)()) {
            PayOut(_recipient, _amount);
            return true;
        } else {
            return false;
        }
    }

&lt;p&gt;and&lt;/p&gt;
if (!rewardAccount.payOut(_account, reward))
    throw;
paidOut[_account] += reward;
return true;

&lt;p&gt;note where the reward is added enabling someone to recursively drain the DAO with multiple calls. This is accidentally mitigated by using msg.sender.send(), but the slock.it team decided to use call here&amp;hellip;a much lower level function that does not put a gas stipend down, enabling a user to call with as much gas as they need from a contract to recursively call the paidOut function. But really, all of this is solved if the line containing:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;paidOut[_account] += reward;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;is simply moved above the payOut function. Crazy I know. Key takeaways from this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1. Make sure you&amp;rsquo;re careful where you place your sends.&lt;/strong&gt;
&lt;strong&gt;2. Don&amp;rsquo;t trust and interact with unknown contracts. If you can&amp;rsquo;t predict what it will do it&amp;rsquo;s very hard to design for it.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;But what about security faults we don&amp;rsquo;t know about yet? What do we do about those. The answer to this question is two fold. It revolves around modular design and smart decentralized decision making.&lt;/p&gt;

&lt;h2 id=&#34;modular-contract-development&#34;&gt;Modular Contract Development&lt;/h2&gt;

&lt;p&gt;The Ethereum community has recently been evoking a trusted hero of my time when it comes to this tragedy: Captain Hindsight.&lt;/p&gt;

&lt;p&gt;{{ page.date | date: &amp;ldquo;%Y&amp;rdquo; | append:&amp;lsquo;/2016-06-18-captainHindSight.jpg&amp;rsquo; | img }}&lt;/p&gt;

&lt;p&gt;With his trusty companions Shoulda, Coulda and Woulda, he swiftly points out that the DAO is far too complex and should have been made with easier and simpler code as well as in a more modular fashion. This would have made the code easier to update as well as audit. Drawing from lessons in the Five Types Model, let&amp;rsquo;s explore the usage of a DOUG or a Decentralized Organization Upgrade Guy.&lt;/p&gt;

&lt;p&gt;Using a DOUG, we would be able to dynamically include more and even reduce the number of contracts, so long as we kept it around a handful of core modules. This would make the code very updateable and easily so. Here&amp;rsquo;s a small example of how it might be designed.&lt;/p&gt;
contract DOUG_Of_Da_DAO {
    // our core modules live here, mapped to a string for ease of update
    mapping(string =&gt; address) coreModules;
    // this is all the dependencies required of our core module.
    // Note that you could combine this with the above to create a triple mapping,
    // but for ease of documentation I am separating it.
    mapping(address =&gt; mapping(string =&gt; address)) moduleDependencies;

    function updateCoreModule(string moduleName, address moduleAddress) {
        coreModules[moduleName] = moduleAddress;
    }

    function updateDependencyModule(string coreModuleName, string dependencyModuleName, address dependencyModuleAddress) {
        moduleDependencies[coreModules[coreModuleName]][dependencyModuleName] = dependencyModuleAddress;
    }

}

&lt;p&gt;You may be asking &amp;ldquo;What&amp;rsquo;s to stop someone from maliciously updating the DAO then to whatever they want it to be&amp;rdquo;. I have purposely left that out of here so that I can tie this into my next bit&amp;hellip;starting now.&lt;/p&gt;

&lt;h2 id=&#34;executive-action&#34;&gt;Executive Action&lt;/h2&gt;

&lt;p&gt;One of the reasons why the United States and many other democratic institutions have an executive branch is for the reason that democracy overall moves far too slowly to respond in moments of crisis.
Seeing this is also why it becomes so tragic for the DAO, because the DAO team had been made aware of the bug and had actually gone in and FIXED their code.
However because there was no executive to decidedly update their code immediately (would have required a vote, which takes quite a sum of time to gather), the attacker was able to jump on the opportunity.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(Side Note: if you ever see a bug that critical, don&#39;t leave it out in the public eye as a white hat, please report it privately if you can. Resort to public disclosure as a last resort if the developer is being an arrogant tool).&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;All forms of security etiquette aside, had the DAO given a group of democratically elected devs executive ability selected in round robin fashion to update the addresses of certain portions of the code in situations like these, this likely would have never happened and been fixed immediately. Let&amp;rsquo;s go back to our DOUG:&lt;/p&gt;
contract DOUG_Of_Da_DAO {
    // our core modules live here, mapped to a string for ease of update
    mapping(string =&gt; address) coreModules;
    // this is all the dependencies required of our core module.
    // Note that you could combine this with the above to create a triple mapping,
    // but for ease of documentation I am separating it.
    mapping(address =&gt; mapping(string =&gt; address)) moduleDependencies;

    function updateCoreModule(string moduleName, address moduleAddress) {
        coreModules[moduleName] = moduleAddress;
    }

    function updateDependencyModule(string coreModuleName, string dependencyModuleName, address dependencyModuleAddress) {
        moduleDependencies[coreModules[coreModuleName]][dependencyModuleName] = dependencyModuleAddress;
    }

}

&lt;p&gt;Suppose we wanted to implement a decentralized security executive. We need to have it created from a vote weighed by the DAOs stakeholders, and we also need to make sure that the security executive cannot maliciously take over the DAO and keep them in power. While we won&amp;rsquo;t go into all of the necessary things (stake deposits that suicide should they make a decision the community dislikes).&lt;/p&gt;

&lt;p&gt;The following is an example of what we would want then in a very centralized fashion. Keep in mind you could get creative with this and make it so that the decision to update is controlled by an odd number of people so that there will always be a resounding yes or no agreement, complete with incentives to make sure that the security people vote. That said it&amp;rsquo;s a little complex for our purposes, so we&amp;rsquo;ll stick with the current way to show a framework for how to do this.&lt;/p&gt;

contract balanceSheet {
    mapping(address =&gt; uint) public balances;
    function getBalance() returns (uint balance) {
        balance = balances[msg.sender];
    }
}

contract securityVote { //holds long term information that will likely not need to change immediately
    //list of modules that security executives are not allowed to update
    address[] blacklist;
    //the current head honcho
    address public currentSecurityExecutive;
    balanceSheet users;
    struct voteNextExec { //could be done with some form of iterable mapping, but this was easier for our purposes
        mapping(address =&gt; bool) initialized;
        mapping(address =&gt; uint) index;
        mapping(address =&gt; bool) voted;
        uint totalCandidates;
        address[] execs;
        uint[] voteWeight;
    }
    voteNextExec vote;
    //time limit to vote in an exec
    uint constant timeLimit = 1 weeks;
    //two key modules that security execs should not be able to update,
    //this current module, and the balance sheet of all user tokens.
    //we will trust the creator in the interim to be a decent security executive but then leave it to the voters.
    function securityVote(address balanceSheetAddr) {
        blacklist.push(balanceSheetAddr);
        blacklist.push(address(this));
        currentSecurityExecutive = msg.sender;
        users = balanceSheet(balanceSheetAddr);
    }

    function voteForSecurityExec(address desired) {
        if (vote.voted[msg.sender]) //if already voted, kick them out
            throw;
        if (vote.initialized[desired]) { //add more to balance
            vote.voted[msg.sender] = true;
            vote.voteWeight[vote.index[desired]] += users.getBalance();
        }
        else { //initialize new candidate
            vote.voted[msg.sender] = true;
            vote.index[desired] = vote.totalCandidates++;
            vote.execs[vote.totalCandidates] = desired;
            vote.voteWeight[vote.index[desired]] = users.getBalance();
        }
    }
}

contract DOUG_Of_Da_DAO {

    address currentSecurityExecutive;
    securityVote currentSecurityConsensus;

    function DOUG_Of_Da_DAO(address securityAddr) {
        currentSecurityConsensus = securityVote(securityAddr);
    }

    modifier currentSecurityGuy() { //only our security guy can update contracts
        if (currentSecurityConsensus.currentSecurityExecutive() != msg.sender)
            throw;
        _
    }
    // our core modules live here, mapped to a string for ease of update
    mapping(string =&gt; address) coreModules;
    // this is all the dependencies required of our core module.
    // Note that you could combine this with the above to create a triple mapping,
    // but for ease of documentation I am separating it.
    mapping(address =&gt; mapping(string =&gt; address)) moduleDependencies;

    function updateCoreModule(string moduleName, address moduleAddress) currentSecurityGuy() {
        coreModules[moduleName] = moduleAddress;
    }

    function updateDependencyModule(string coreModuleName, string dependencyModuleName, address dependencyModuleAddress) currentSecurityGuy() {
        moduleDependencies[coreModules[coreModuleName]][dependencyModuleName] = dependencyModuleAddress;
    }

}

&lt;h2 id=&#34;what-solidity-is-doing-about-this&#34;&gt;What Solidity Is Doing About This&lt;/h2&gt;

&lt;p&gt;Currently we are talking about ways to minimize reentrancy attack. There is an issue up in the Solidity github that discusses a suggestion from &lt;a href=&#34;https://github.com/ethereum/solidity/issues/662&#34; target=&#34;_blank&#34;&gt;Micah Zoltu&lt;/a&gt; to add a default boolean in all external calls that prevents recursive calls. For people who know what they&amp;rsquo;re doing and want recursive calls, the default mechanism could be overridden by people who know what they are doing with a universal modifier named &amp;ldquo;reentrant&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Beyond that, Christian and I are working tirelessly to bring you new features for Solidity as well as better documentation of best practices whenever you are coding smart contracts. We hope that this will be the beginning of NASA like documentation of attacks and what and what not to do whenever coding in Solidity.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>