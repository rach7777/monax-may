<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
&lt;?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Eris Chains on Monax Industries</title>
    <link>http://localhost/tags/eris-chains/</link>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Sep 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost/tags/eris-chains/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Eris CLI Chains Walkabout: New</title>
      <link>http://localhost/2015/09/06/introing-eris-chains/</link>
      <pubDate>Sun, 06 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid isPermaLink="true">http://localhost/2015/09/06/introing-eris-chains/</guid>
      <description>&lt;p&gt;{% include series.html %}&lt;/p&gt;

&lt;p&gt;We, surprisingly, keep getting inbound communcation which queries why we are not &amp;ldquo;making&amp;rdquo; permissioned blockchains &amp;ldquo;any more&amp;rdquo;. This is surprising to me for two reasons, the first is because many folks seemed to utterly detest the &lt;em&gt;idea&lt;/em&gt; of permissioned blockchains at all. Full Stop. We called this, in the spring, (internally) the great blockchains war. It wasn&amp;rsquo;t really a war to us at all. We do not view permissioned or unpermissioned chains as competitors of one another any more than we view Cassandra and Mongo as competitors of one another. While both exist in the generalized database space, they are very different tools for very different things. Yet, despite the perspective that these are different tools to accomplish different purposes, folks seemed to get very religious about their blockchain designs and feel very passionate about one chain design vis a vis another. At Eris we are not religious about our blockchain designs.&lt;/p&gt;

&lt;p&gt;The second reason that this inbound is surprising to me, is that we haven&amp;rsquo;t actually stopped making permissioned blockchains. We have &lt;strong&gt;continued our work&lt;/strong&gt; in the permissioned blockchain (really, permissioned smart contract network) space only we are doing so in collaboration with the Tendermint open source project rather than under the Eris namespace. Almost all of the learning and effort which we put into crafting thelonious has been captured, improved, and reworked into the Tendermint project&amp;rsquo;s blockchain design. Indeed, that blockchain is fully permissionable out of the box due to our efforts and what we learned while building thelonious.&lt;/p&gt;

&lt;p&gt;Lastly, I&amp;rsquo;d like to remind folks that the &lt;code&gt;eris&lt;/code&gt; tool is &lt;strong&gt;optimized for working with permissioned smart contract networks&lt;/strong&gt;. It does run public blockchains out of the box, and for those that want to run public blockchains which we do not have a service definition file built for, it is as easy as making sure that the blockchain in question has a Docker image and making a service definition file for it (which is usually only a few lines).&lt;/p&gt;

&lt;p&gt;So, how does &lt;code&gt;eris&lt;/code&gt; work with permissioned smart contract networks? In general it provides some very convenient wrapping around the &lt;code&gt;eris chain manager&lt;/code&gt; scripts which we make sure to compile into the the &lt;code&gt;eris/erisdb&lt;/code&gt; Docker image (for more on Docker see the &lt;a href=&#34;https://eng.erisindustries.com/tutorials/2015/09/05/docker-and-eris/&#34; target=&#34;_blank&#34;&gt;Eris CLI Walkabout post on Docker&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;This post will speak to &lt;code&gt;eris chains new&lt;/code&gt; which is how &lt;code&gt;eris&lt;/code&gt; supports hashing a new permissioned smart contract network.&lt;/p&gt;

&lt;p&gt;When one does &lt;code&gt;eris chains new test_chain&lt;/code&gt; then what eris will do, if no flags are given, is to read the default chain configuration files from &lt;code&gt;~/.eris/chains/config/default&lt;/code&gt; and hash a new chain it will call &lt;code&gt;test_chain&lt;/code&gt;. These default configuration files are written to the host hard drive (in the location noted above) during the &lt;code&gt;eris init&lt;/code&gt; process.&lt;/p&gt;

&lt;p&gt;Once the files have been copied into a data container, then eris is ready to start a service which will hash the blockchain into existence. To do this we use the &lt;code&gt;eris/erisdb&lt;/code&gt; container with the volumes from the data container mounted. This separates out the data which the process will run against from the actual operation process (computational sequence) itself.&lt;/p&gt;

&lt;p&gt;When the chain has been hashed, then it will not be started and the service container will be removed, leaving &lt;strong&gt;only&lt;/strong&gt; a container which will likely look something like this: &lt;code&gt;eris_data_test_chain_1&lt;/code&gt;. If you do &lt;code&gt;docker ps -a&lt;/code&gt; after running &lt;code&gt;eris chains new test_chain&lt;/code&gt; this is likely all you will see. We have an issue open to change this default so that after a chain is hashed then the chain starts running, but for now that is not the default behaviour.&lt;/p&gt;

&lt;p&gt;So if you do &lt;code&gt;eris chains ls&lt;/code&gt; after doing &lt;code&gt;eris chains new test_chain&lt;/code&gt; you will not actually see a chain. This is expected behaviour because what &lt;code&gt;eris chains ls&lt;/code&gt; will do is to read from docker the existing chain type containers, but there will not be any chain type containers (unless you have other chains) at this point. In order to start running the chain you just created you will type &lt;code&gt;eris chains start test_chain&lt;/code&gt;. This will create the running service container and use the &lt;code&gt;test_chain&lt;/code&gt; data container. Once you have started the chain running if you do &lt;code&gt;eris chains ls&lt;/code&gt; again you will see &lt;code&gt;test_chain&lt;/code&gt; there.&lt;/p&gt;

&lt;p&gt;Now, you will not always want to have the chain be hashed with the default configuration (which we make sure is available only for quick test chains and it should &lt;strong&gt;never&lt;/strong&gt; be used for non-test chains). To create a chain which you would want to use for your application, rather than simply for quick testing, you will want to update the config files appropriately. To do this, the easiest way to start is to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp -r ~/.eris/chains/config/default ~/.eris/chains/config/mychain14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will copy the default configuration files into a new directory. At this point open the default configuration files in your text editor and edit them as necessary for your setup. At the end then you will do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eris chains new mychain14 --dir ~/.eris/chains/config/mychain14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the &lt;code&gt;--dir&lt;/code&gt; flag is given to chains new, it will read the configuration files from that directory rather than the &lt;code&gt;~/.eris/chains/config/default&lt;/code&gt; and use those instead of the default configuration files when hashing the new chain. For an even more lightweight solution you can give it a genesis.json and or a set of validator.csv and accounts.csv files to use via different flags. There will be another onboarding post about these files coming soon.&lt;/p&gt;

&lt;p&gt;If you have any questions about the chains hashing process please do not hestitate to visit our &lt;a href=&#34;https://support.erisindustries.com&#34; target=&#34;_blank&#34;&gt;forums&lt;/a&gt; or leave a comment below and we will try to answer as quickly as we can.&lt;/p&gt;

&lt;p&gt;Happy (permissioned) blockchaining!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>